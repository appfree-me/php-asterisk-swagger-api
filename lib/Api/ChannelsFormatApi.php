<?php
/**
 * ChannelsFormatApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.43
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * ChannelsFormatApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ChannelsFormatApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation answer
     *
     * Answer a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function answer($channel_id)
    {
        $this->answerWithHttpInfo($channel_id);
    }

    /**
     * Operation answerWithHttpInfo
     *
     * Answer a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function answerWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->answerRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation answerAsync
     *
     * Answer a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function answerAsync($channel_id)
    {
        return $this->answerAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation answerAsyncWithHttpInfo
     *
     * Answer a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function answerAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->answerRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'answer'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function answerRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling answer'
            );
        }

        $resourcePath = '/channels/{channelId}/answer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callList
     *
     * List all active channels in Asterisk.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callList()
    {
        $this->callListWithHttpInfo();
    }

    /**
     * Operation callListWithHttpInfo
     *
     * List all active channels in Asterisk.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callListWithHttpInfo()
    {
        $returnType = '';
        $request = $this->callListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callListAsync
     *
     * List all active channels in Asterisk.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callListAsync()
    {
        return $this->callListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callListAsyncWithHttpInfo
     *
     * List all active channels in Asterisk.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callListAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->callListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callListRequest()
    {

        $resourcePath = '/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation continueInDialplan
     *
     * Exit application; continue execution in the dialplan.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $context The context to continue to. (optional)
     * @param  string $extension The extension to continue to. (optional)
     * @param  int $priority The priority to continue to. (optional)
     * @param  string $label The label to continue to - will supersede &#39;priority&#39; if both are provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function continueInDialplan($channel_id, $context = null, $extension = null, $priority = null, $label = null)
    {
        $this->continueInDialplanWithHttpInfo($channel_id, $context, $extension, $priority, $label);
    }

    /**
     * Operation continueInDialplanWithHttpInfo
     *
     * Exit application; continue execution in the dialplan.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $context The context to continue to. (optional)
     * @param  string $extension The extension to continue to. (optional)
     * @param  int $priority The priority to continue to. (optional)
     * @param  string $label The label to continue to - will supersede &#39;priority&#39; if both are provided. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function continueInDialplanWithHttpInfo($channel_id, $context = null, $extension = null, $priority = null, $label = null)
    {
        $returnType = '';
        $request = $this->continueInDialplanRequest($channel_id, $context, $extension, $priority, $label);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation continueInDialplanAsync
     *
     * Exit application; continue execution in the dialplan.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $context The context to continue to. (optional)
     * @param  string $extension The extension to continue to. (optional)
     * @param  int $priority The priority to continue to. (optional)
     * @param  string $label The label to continue to - will supersede &#39;priority&#39; if both are provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function continueInDialplanAsync($channel_id, $context = null, $extension = null, $priority = null, $label = null)
    {
        return $this->continueInDialplanAsyncWithHttpInfo($channel_id, $context, $extension, $priority, $label)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation continueInDialplanAsyncWithHttpInfo
     *
     * Exit application; continue execution in the dialplan.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $context The context to continue to. (optional)
     * @param  string $extension The extension to continue to. (optional)
     * @param  int $priority The priority to continue to. (optional)
     * @param  string $label The label to continue to - will supersede &#39;priority&#39; if both are provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function continueInDialplanAsyncWithHttpInfo($channel_id, $context = null, $extension = null, $priority = null, $label = null)
    {
        $returnType = '';
        $request = $this->continueInDialplanRequest($channel_id, $context, $extension, $priority, $label);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'continueInDialplan'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $context The context to continue to. (optional)
     * @param  string $extension The extension to continue to. (optional)
     * @param  int $priority The priority to continue to. (optional)
     * @param  string $label The label to continue to - will supersede &#39;priority&#39; if both are provided. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function continueInDialplanRequest($channel_id, $context = null, $extension = null, $priority = null, $label = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling continueInDialplan'
            );
        }

        $resourcePath = '/channels/{channelId}/continue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context);
        }
        // query params
        if ($extension !== null) {
            $queryParams['extension'] = ObjectSerializer::toQueryValue($extension);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority);
        }
        // query params
        if ($label !== null) {
            $queryParams['label'] = ObjectSerializer::toQueryValue($label);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation create
     *
     * Create channel.
     *
     * @param  string $endpoint Endpoint for channel communication (required)
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator Unique ID of the calling channel (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function create($endpoint, $app, $app_args = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null, $variables = null)
    {
        $this->createWithHttpInfo($endpoint, $app, $app_args, $channel_id, $other_channel_id, $originator, $formats, $variables);
    }

    /**
     * Operation createWithHttpInfo
     *
     * Create channel.
     *
     * @param  string $endpoint Endpoint for channel communication (required)
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator Unique ID of the calling channel (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithHttpInfo($endpoint, $app, $app_args = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null, $variables = null)
    {
        $returnType = '';
        $request = $this->createRequest($endpoint, $app, $app_args, $channel_id, $other_channel_id, $originator, $formats, $variables);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAsync
     *
     * Create channel.
     *
     * @param  string $endpoint Endpoint for channel communication (required)
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator Unique ID of the calling channel (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsync($endpoint, $app, $app_args = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null, $variables = null)
    {
        return $this->createAsyncWithHttpInfo($endpoint, $app, $app_args, $channel_id, $other_channel_id, $originator, $formats, $variables)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAsyncWithHttpInfo
     *
     * Create channel.
     *
     * @param  string $endpoint Endpoint for channel communication (required)
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator Unique ID of the calling channel (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsyncWithHttpInfo($endpoint, $app, $app_args = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null, $variables = null)
    {
        $returnType = '';
        $request = $this->createRequest($endpoint, $app, $app_args, $channel_id, $other_channel_id, $originator, $formats, $variables);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'create'
     *
     * @param  string $endpoint Endpoint for channel communication (required)
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator Unique ID of the calling channel (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRequest($endpoint, $app, $app_args = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null, $variables = null)
    {
        // verify the required parameter 'endpoint' is set
        if ($endpoint === null || (is_array($endpoint) && count($endpoint) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint when calling create'
            );
        }
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling create'
            );
        }

        $resourcePath = '/channels/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($endpoint !== null) {
            $queryParams['endpoint'] = ObjectSerializer::toQueryValue($endpoint);
        }
        // query params
        if ($app !== null) {
            $queryParams['app'] = ObjectSerializer::toQueryValue($app);
        }
        // query params
        if ($app_args !== null) {
            $queryParams['appArgs'] = ObjectSerializer::toQueryValue($app_args);
        }
        // query params
        if ($channel_id !== null) {
            $queryParams['channelId'] = ObjectSerializer::toQueryValue($channel_id);
        }
        // query params
        if ($other_channel_id !== null) {
            $queryParams['otherChannelId'] = ObjectSerializer::toQueryValue($other_channel_id);
        }
        // query params
        if ($originator !== null) {
            $queryParams['originator'] = ObjectSerializer::toQueryValue($originator);
        }
        // query params
        if ($formats !== null) {
            $queryParams['formats'] = ObjectSerializer::toQueryValue($formats);
        }


        // body params
        $_tempBody = null;
        if (isset($variables)) {
            $_tempBody = $variables;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation dial
     *
     * Dial a created channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $caller Channel ID of caller (optional)
     * @param  int $timeout Dial timeout (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function dial($channel_id, $caller = null, $timeout = '0')
    {
        $this->dialWithHttpInfo($channel_id, $caller, $timeout);
    }

    /**
     * Operation dialWithHttpInfo
     *
     * Dial a created channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $caller Channel ID of caller (optional)
     * @param  int $timeout Dial timeout (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function dialWithHttpInfo($channel_id, $caller = null, $timeout = '0')
    {
        $returnType = '';
        $request = $this->dialRequest($channel_id, $caller, $timeout);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation dialAsync
     *
     * Dial a created channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $caller Channel ID of caller (optional)
     * @param  int $timeout Dial timeout (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dialAsync($channel_id, $caller = null, $timeout = '0')
    {
        return $this->dialAsyncWithHttpInfo($channel_id, $caller, $timeout)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation dialAsyncWithHttpInfo
     *
     * Dial a created channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $caller Channel ID of caller (optional)
     * @param  int $timeout Dial timeout (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function dialAsyncWithHttpInfo($channel_id, $caller = null, $timeout = '0')
    {
        $returnType = '';
        $request = $this->dialRequest($channel_id, $caller, $timeout);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'dial'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $caller Channel ID of caller (optional)
     * @param  int $timeout Dial timeout (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function dialRequest($channel_id, $caller = null, $timeout = '0')
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling dial'
            );
        }

        $resourcePath = '/channels/{channelId}/dial';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($caller !== null) {
            $queryParams['caller'] = ObjectSerializer::toQueryValue($caller);
        }
        // query params
        if ($timeout !== null) {
            $queryParams['timeout'] = ObjectSerializer::toQueryValue($timeout);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation externalMedia
     *
     * Start an External Media session.
     *
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $external_host Hostname/ip:port of external host (required)
     * @param  string $format Format to encode audio in (required)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $encapsulation Payload encapsulation protocol (optional, default to rtp)
     * @param  string $transport Transport protocol (optional, default to udp)
     * @param  string $connection_type Connection type (client/server) (optional, default to client)
     * @param  string $direction External media direction (optional, default to both)
     * @param  string $data An arbitrary data field (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function externalMedia($app, $external_host, $format, $channel_id = null, $variables = null, $encapsulation = 'rtp', $transport = 'udp', $connection_type = 'client', $direction = 'both', $data = null)
    {
        $this->externalMediaWithHttpInfo($app, $external_host, $format, $channel_id, $variables, $encapsulation, $transport, $connection_type, $direction, $data);
    }

    /**
     * Operation externalMediaWithHttpInfo
     *
     * Start an External Media session.
     *
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $external_host Hostname/ip:port of external host (required)
     * @param  string $format Format to encode audio in (required)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $encapsulation Payload encapsulation protocol (optional, default to rtp)
     * @param  string $transport Transport protocol (optional, default to udp)
     * @param  string $connection_type Connection type (client/server) (optional, default to client)
     * @param  string $direction External media direction (optional, default to both)
     * @param  string $data An arbitrary data field (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function externalMediaWithHttpInfo($app, $external_host, $format, $channel_id = null, $variables = null, $encapsulation = 'rtp', $transport = 'udp', $connection_type = 'client', $direction = 'both', $data = null)
    {
        $returnType = '';
        $request = $this->externalMediaRequest($app, $external_host, $format, $channel_id, $variables, $encapsulation, $transport, $connection_type, $direction, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation externalMediaAsync
     *
     * Start an External Media session.
     *
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $external_host Hostname/ip:port of external host (required)
     * @param  string $format Format to encode audio in (required)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $encapsulation Payload encapsulation protocol (optional, default to rtp)
     * @param  string $transport Transport protocol (optional, default to udp)
     * @param  string $connection_type Connection type (client/server) (optional, default to client)
     * @param  string $direction External media direction (optional, default to both)
     * @param  string $data An arbitrary data field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function externalMediaAsync($app, $external_host, $format, $channel_id = null, $variables = null, $encapsulation = 'rtp', $transport = 'udp', $connection_type = 'client', $direction = 'both', $data = null)
    {
        return $this->externalMediaAsyncWithHttpInfo($app, $external_host, $format, $channel_id, $variables, $encapsulation, $transport, $connection_type, $direction, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation externalMediaAsyncWithHttpInfo
     *
     * Start an External Media session.
     *
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $external_host Hostname/ip:port of external host (required)
     * @param  string $format Format to encode audio in (required)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $encapsulation Payload encapsulation protocol (optional, default to rtp)
     * @param  string $transport Transport protocol (optional, default to udp)
     * @param  string $connection_type Connection type (client/server) (optional, default to client)
     * @param  string $direction External media direction (optional, default to both)
     * @param  string $data An arbitrary data field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function externalMediaAsyncWithHttpInfo($app, $external_host, $format, $channel_id = null, $variables = null, $encapsulation = 'rtp', $transport = 'udp', $connection_type = 'client', $direction = 'both', $data = null)
    {
        $returnType = '';
        $request = $this->externalMediaRequest($app, $external_host, $format, $channel_id, $variables, $encapsulation, $transport, $connection_type, $direction, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'externalMedia'
     *
     * @param  string $app Stasis Application to place channel into (required)
     * @param  string $external_host Hostname/ip:port of external host (required)
     * @param  string $format Format to encode audio in (required)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $encapsulation Payload encapsulation protocol (optional, default to rtp)
     * @param  string $transport Transport protocol (optional, default to udp)
     * @param  string $connection_type Connection type (client/server) (optional, default to client)
     * @param  string $direction External media direction (optional, default to both)
     * @param  string $data An arbitrary data field (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function externalMediaRequest($app, $external_host, $format, $channel_id = null, $variables = null, $encapsulation = 'rtp', $transport = 'udp', $connection_type = 'client', $direction = 'both', $data = null)
    {
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling externalMedia'
            );
        }
        // verify the required parameter 'external_host' is set
        if ($external_host === null || (is_array($external_host) && count($external_host) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $external_host when calling externalMedia'
            );
        }
        // verify the required parameter 'format' is set
        if ($format === null || (is_array($format) && count($format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $format when calling externalMedia'
            );
        }

        $resourcePath = '/channels/externalMedia';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($channel_id !== null) {
            $queryParams['channelId'] = ObjectSerializer::toQueryValue($channel_id);
        }
        // query params
        if ($app !== null) {
            $queryParams['app'] = ObjectSerializer::toQueryValue($app);
        }
        // query params
        if ($external_host !== null) {
            $queryParams['external_host'] = ObjectSerializer::toQueryValue($external_host);
        }
        // query params
        if ($encapsulation !== null) {
            $queryParams['encapsulation'] = ObjectSerializer::toQueryValue($encapsulation);
        }
        // query params
        if ($transport !== null) {
            $queryParams['transport'] = ObjectSerializer::toQueryValue($transport);
        }
        // query params
        if ($connection_type !== null) {
            $queryParams['connection_type'] = ObjectSerializer::toQueryValue($connection_type);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }
        // query params
        if ($data !== null) {
            $queryParams['data'] = ObjectSerializer::toQueryValue($data);
        }


        // body params
        $_tempBody = null;
        if (isset($variables)) {
            $_tempBody = $variables;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation get
     *
     * Channel details.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function get($channel_id)
    {
        $this->getWithHttpInfo($channel_id);
    }

    /**
     * Operation getWithHttpInfo
     *
     * Channel details.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->getRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getAsync
     *
     * Channel details.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsync($channel_id)
    {
        return $this->getAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAsyncWithHttpInfo
     *
     * Channel details.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->getRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'get'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling get'
            );
        }

        $resourcePath = '/channels/{channelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getChannelVar
     *
     * Get the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to get (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getChannelVar($channel_id, $variable)
    {
        $this->getChannelVarWithHttpInfo($channel_id, $variable);
    }

    /**
     * Operation getChannelVarWithHttpInfo
     *
     * Get the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to get (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getChannelVarWithHttpInfo($channel_id, $variable)
    {
        $returnType = '';
        $request = $this->getChannelVarRequest($channel_id, $variable);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getChannelVarAsync
     *
     * Get the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelVarAsync($channel_id, $variable)
    {
        return $this->getChannelVarAsyncWithHttpInfo($channel_id, $variable)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getChannelVarAsyncWithHttpInfo
     *
     * Get the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getChannelVarAsyncWithHttpInfo($channel_id, $variable)
    {
        $returnType = '';
        $request = $this->getChannelVarRequest($channel_id, $variable);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getChannelVar'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to get (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getChannelVarRequest($channel_id, $variable)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling getChannelVar'
            );
        }
        // verify the required parameter 'variable' is set
        if ($variable === null || (is_array($variable) && count($variable) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable when calling getChannelVar'
            );
        }

        $resourcePath = '/channels/{channelId}/variable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variable !== null) {
            $queryParams['variable'] = ObjectSerializer::toQueryValue($variable);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hangup
     *
     * Delete (i.e. hangup) a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $reason_code The reason code for hanging up the channel for detail use. Mutually exclusive with &#39;reason&#39;. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings (optional)
     * @param  string $reason Reason for hanging up the channel for simple use. Mutually exclusive with &#39;reason_code&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function hangup($channel_id, $reason_code = null, $reason = null)
    {
        $this->hangupWithHttpInfo($channel_id, $reason_code, $reason);
    }

    /**
     * Operation hangupWithHttpInfo
     *
     * Delete (i.e. hangup) a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $reason_code The reason code for hanging up the channel for detail use. Mutually exclusive with &#39;reason&#39;. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings (optional)
     * @param  string $reason Reason for hanging up the channel for simple use. Mutually exclusive with &#39;reason_code&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function hangupWithHttpInfo($channel_id, $reason_code = null, $reason = null)
    {
        $returnType = '';
        $request = $this->hangupRequest($channel_id, $reason_code, $reason);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation hangupAsync
     *
     * Delete (i.e. hangup) a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $reason_code The reason code for hanging up the channel for detail use. Mutually exclusive with &#39;reason&#39;. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings (optional)
     * @param  string $reason Reason for hanging up the channel for simple use. Mutually exclusive with &#39;reason_code&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hangupAsync($channel_id, $reason_code = null, $reason = null)
    {
        return $this->hangupAsyncWithHttpInfo($channel_id, $reason_code, $reason)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hangupAsyncWithHttpInfo
     *
     * Delete (i.e. hangup) a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $reason_code The reason code for hanging up the channel for detail use. Mutually exclusive with &#39;reason&#39;. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings (optional)
     * @param  string $reason Reason for hanging up the channel for simple use. Mutually exclusive with &#39;reason_code&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hangupAsyncWithHttpInfo($channel_id, $reason_code = null, $reason = null)
    {
        $returnType = '';
        $request = $this->hangupRequest($channel_id, $reason_code, $reason);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hangup'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $reason_code The reason code for hanging up the channel for detail use. Mutually exclusive with &#39;reason&#39;. See detail hangup codes at here. https://wiki.asterisk.org/wiki/display/AST/Hangup+Cause+Mappings (optional)
     * @param  string $reason Reason for hanging up the channel for simple use. Mutually exclusive with &#39;reason_code&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function hangupRequest($channel_id, $reason_code = null, $reason = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling hangup'
            );
        }

        $resourcePath = '/channels/{channelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($reason_code !== null) {
            $queryParams['reason_code'] = ObjectSerializer::toQueryValue($reason_code);
        }
        // query params
        if ($reason !== null) {
            $queryParams['reason'] = ObjectSerializer::toQueryValue($reason);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hold
     *
     * Hold a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function hold($channel_id)
    {
        $this->holdWithHttpInfo($channel_id);
    }

    /**
     * Operation holdWithHttpInfo
     *
     * Hold a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function holdWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->holdRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation holdAsync
     *
     * Hold a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holdAsync($channel_id)
    {
        return $this->holdAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation holdAsyncWithHttpInfo
     *
     * Hold a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function holdAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->holdRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hold'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function holdRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling hold'
            );
        }

        $resourcePath = '/channels/{channelId}/hold';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation move
     *
     * Move the channel from one Stasis application to another.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app The channel will be passed to this Stasis application. (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function move($channel_id, $app, $app_args = null)
    {
        $this->moveWithHttpInfo($channel_id, $app, $app_args);
    }

    /**
     * Operation moveWithHttpInfo
     *
     * Move the channel from one Stasis application to another.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app The channel will be passed to this Stasis application. (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveWithHttpInfo($channel_id, $app, $app_args = null)
    {
        $returnType = '';
        $request = $this->moveRequest($channel_id, $app, $app_args);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation moveAsync
     *
     * Move the channel from one Stasis application to another.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app The channel will be passed to this Stasis application. (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveAsync($channel_id, $app, $app_args = null)
    {
        return $this->moveAsyncWithHttpInfo($channel_id, $app, $app_args)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveAsyncWithHttpInfo
     *
     * Move the channel from one Stasis application to another.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app The channel will be passed to this Stasis application. (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveAsyncWithHttpInfo($channel_id, $app, $app_args = null)
    {
        $returnType = '';
        $request = $this->moveRequest($channel_id, $app, $app_args);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'move'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app The channel will be passed to this Stasis application. (required)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function moveRequest($channel_id, $app, $app_args = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling move'
            );
        }
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling move'
            );
        }

        $resourcePath = '/channels/{channelId}/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($app !== null) {
            $queryParams['app'] = ObjectSerializer::toQueryValue($app);
        }
        // query params
        if ($app_args !== null) {
            $queryParams['appArgs'] = ObjectSerializer::toQueryValue($app_args);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mute
     *
     * Mute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to mute audio (optional, default to both)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function mute($channel_id, $direction = 'both')
    {
        $this->muteWithHttpInfo($channel_id, $direction);
    }

    /**
     * Operation muteWithHttpInfo
     *
     * Mute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to mute audio (optional, default to both)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function muteWithHttpInfo($channel_id, $direction = 'both')
    {
        $returnType = '';
        $request = $this->muteRequest($channel_id, $direction);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation muteAsync
     *
     * Mute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to mute audio (optional, default to both)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function muteAsync($channel_id, $direction = 'both')
    {
        return $this->muteAsyncWithHttpInfo($channel_id, $direction)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation muteAsyncWithHttpInfo
     *
     * Mute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to mute audio (optional, default to both)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function muteAsyncWithHttpInfo($channel_id, $direction = 'both')
    {
        $returnType = '';
        $request = $this->muteRequest($channel_id, $direction);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mute'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to mute audio (optional, default to both)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function muteRequest($channel_id, $direction = 'both')
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling mute'
            );
        }

        $resourcePath = '/channels/{channelId}/mute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation originate
     *
     * Create a new channel (originate).
     *
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function originate($endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        $this->originateWithHttpInfo($endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $channel_id, $other_channel_id, $originator, $formats);
    }

    /**
     * Operation originateWithHttpInfo
     *
     * Create a new channel (originate).
     *
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function originateWithHttpInfo($endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        $returnType = '';
        $request = $this->originateRequest($endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $channel_id, $other_channel_id, $originator, $formats);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation originateAsync
     *
     * Create a new channel (originate).
     *
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originateAsync($endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        return $this->originateAsyncWithHttpInfo($endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $channel_id, $other_channel_id, $originator, $formats)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation originateAsyncWithHttpInfo
     *
     * Create a new channel (originate).
     *
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originateAsyncWithHttpInfo($endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        $returnType = '';
        $request = $this->originateRequest($endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $channel_id, $other_channel_id, $originator, $formats);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'originate'
     *
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $channel_id The unique id to assign the channel on creation. (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function originateRequest($endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $channel_id = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        // verify the required parameter 'endpoint' is set
        if ($endpoint === null || (is_array($endpoint) && count($endpoint) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint when calling originate'
            );
        }

        $resourcePath = '/channels';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($endpoint !== null) {
            $queryParams['endpoint'] = ObjectSerializer::toQueryValue($endpoint);
        }
        // query params
        if ($extension !== null) {
            $queryParams['extension'] = ObjectSerializer::toQueryValue($extension);
        }
        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority);
        }
        // query params
        if ($label !== null) {
            $queryParams['label'] = ObjectSerializer::toQueryValue($label);
        }
        // query params
        if ($app !== null) {
            $queryParams['app'] = ObjectSerializer::toQueryValue($app);
        }
        // query params
        if ($app_args !== null) {
            $queryParams['appArgs'] = ObjectSerializer::toQueryValue($app_args);
        }
        // query params
        if ($caller_id !== null) {
            $queryParams['callerId'] = ObjectSerializer::toQueryValue($caller_id);
        }
        // query params
        if ($timeout !== null) {
            $queryParams['timeout'] = ObjectSerializer::toQueryValue($timeout);
        }
        // query params
        if ($channel_id !== null) {
            $queryParams['channelId'] = ObjectSerializer::toQueryValue($channel_id);
        }
        // query params
        if ($other_channel_id !== null) {
            $queryParams['otherChannelId'] = ObjectSerializer::toQueryValue($other_channel_id);
        }
        // query params
        if ($originator !== null) {
            $queryParams['originator'] = ObjectSerializer::toQueryValue($originator);
        }
        // query params
        if ($formats !== null) {
            $queryParams['formats'] = ObjectSerializer::toQueryValue($formats);
        }


        // body params
        $_tempBody = null;
        if (isset($variables)) {
            $_tempBody = $variables;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation originateWithId
     *
     * Create a new channel (originate with id).
     *
     * @param  string $channel_id The unique id to assign the channel on creation. (required)
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function originateWithId($channel_id, $endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        $this->originateWithIdWithHttpInfo($channel_id, $endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $other_channel_id, $originator, $formats);
    }

    /**
     * Operation originateWithIdWithHttpInfo
     *
     * Create a new channel (originate with id).
     *
     * @param  string $channel_id The unique id to assign the channel on creation. (required)
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function originateWithIdWithHttpInfo($channel_id, $endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        $returnType = '';
        $request = $this->originateWithIdRequest($channel_id, $endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $other_channel_id, $originator, $formats);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation originateWithIdAsync
     *
     * Create a new channel (originate with id).
     *
     * @param  string $channel_id The unique id to assign the channel on creation. (required)
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originateWithIdAsync($channel_id, $endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        return $this->originateWithIdAsyncWithHttpInfo($channel_id, $endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $other_channel_id, $originator, $formats)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation originateWithIdAsyncWithHttpInfo
     *
     * Create a new channel (originate with id).
     *
     * @param  string $channel_id The unique id to assign the channel on creation. (required)
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originateWithIdAsyncWithHttpInfo($channel_id, $endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        $returnType = '';
        $request = $this->originateWithIdRequest($channel_id, $endpoint, $extension, $context, $priority, $label, $app, $app_args, $caller_id, $timeout, $variables, $other_channel_id, $originator, $formats);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'originateWithId'
     *
     * @param  string $channel_id The unique id to assign the channel on creation. (required)
     * @param  string $endpoint Endpoint to call. (required)
     * @param  string $extension The extension to dial after the endpoint answers. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $context The context to dial after the endpoint answers. If omitted, uses &#39;default&#39;. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  int $priority The priority to dial after the endpoint answers. If omitted, uses 1. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $label The label to dial after the endpoint answers. Will supersede &#39;priority&#39; if provided. Mutually exclusive with &#39;app&#39;. (optional)
     * @param  string $app The application that is subscribed to the originated channel. When the channel is answered, it will be passed to this Stasis application. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $app_args The application arguments to pass to the Stasis application provided by &#39;app&#39;. Mutually exclusive with &#39;context&#39;, &#39;extension&#39;, &#39;priority&#39;, and &#39;label&#39;. (optional)
     * @param  string $caller_id CallerID to use when dialing the endpoint or extension. (optional)
     * @param  int $timeout Timeout (in seconds) before giving up dialing, or -1 for no timeout. (optional, default to 30)
     * @param  \Swagger\Client\Model\Containers $variables The \&quot;variables\&quot; key in the body object holds variable key/value pairs to set on the channel on creation. Other keys in the body object are interpreted as query parameters. Ex. { \&quot;endpoint\&quot;: \&quot;SIP/Alice\&quot;, \&quot;variables\&quot;: { \&quot;CALLERID(name)\&quot;: \&quot;Alice\&quot; } } (optional)
     * @param  string $other_channel_id The unique id to assign the second channel when using local channels. (optional)
     * @param  string $originator The unique id of the channel which is originating this one. (optional)
     * @param  string $formats The format name capability list to use if originator is not specified. Ex. \&quot;ulaw,slin16\&quot;.  Format names can be found with \&quot;core show codecs\&quot;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function originateWithIdRequest($channel_id, $endpoint, $extension = null, $context = null, $priority = null, $label = null, $app = null, $app_args = null, $caller_id = null, $timeout = '30', $variables = null, $other_channel_id = null, $originator = null, $formats = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling originateWithId'
            );
        }
        // verify the required parameter 'endpoint' is set
        if ($endpoint === null || (is_array($endpoint) && count($endpoint) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint when calling originateWithId'
            );
        }

        $resourcePath = '/channels/{channelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($endpoint !== null) {
            $queryParams['endpoint'] = ObjectSerializer::toQueryValue($endpoint);
        }
        // query params
        if ($extension !== null) {
            $queryParams['extension'] = ObjectSerializer::toQueryValue($extension);
        }
        // query params
        if ($context !== null) {
            $queryParams['context'] = ObjectSerializer::toQueryValue($context);
        }
        // query params
        if ($priority !== null) {
            $queryParams['priority'] = ObjectSerializer::toQueryValue($priority);
        }
        // query params
        if ($label !== null) {
            $queryParams['label'] = ObjectSerializer::toQueryValue($label);
        }
        // query params
        if ($app !== null) {
            $queryParams['app'] = ObjectSerializer::toQueryValue($app);
        }
        // query params
        if ($app_args !== null) {
            $queryParams['appArgs'] = ObjectSerializer::toQueryValue($app_args);
        }
        // query params
        if ($caller_id !== null) {
            $queryParams['callerId'] = ObjectSerializer::toQueryValue($caller_id);
        }
        // query params
        if ($timeout !== null) {
            $queryParams['timeout'] = ObjectSerializer::toQueryValue($timeout);
        }
        // query params
        if ($other_channel_id !== null) {
            $queryParams['otherChannelId'] = ObjectSerializer::toQueryValue($other_channel_id);
        }
        // query params
        if ($originator !== null) {
            $queryParams['originator'] = ObjectSerializer::toQueryValue($originator);
        }
        // query params
        if ($formats !== null) {
            $queryParams['formats'] = ObjectSerializer::toQueryValue($formats);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($variables)) {
            $_tempBody = $variables;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation play
     *
     * Start playback of media.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback ID. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function play($channel_id, $media, $lang = null, $offsetms = null, $skipms = '3000', $playback_id = null)
    {
        $this->playWithHttpInfo($channel_id, $media, $lang, $offsetms, $skipms, $playback_id);
    }

    /**
     * Operation playWithHttpInfo
     *
     * Start playback of media.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback ID. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function playWithHttpInfo($channel_id, $media, $lang = null, $offsetms = null, $skipms = '3000', $playback_id = null)
    {
        $returnType = '';
        $request = $this->playRequest($channel_id, $media, $lang, $offsetms, $skipms, $playback_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation playAsync
     *
     * Start playback of media.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playAsync($channel_id, $media, $lang = null, $offsetms = null, $skipms = '3000', $playback_id = null)
    {
        return $this->playAsyncWithHttpInfo($channel_id, $media, $lang, $offsetms, $skipms, $playback_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playAsyncWithHttpInfo
     *
     * Start playback of media.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playAsyncWithHttpInfo($channel_id, $media, $lang = null, $offsetms = null, $skipms = '3000', $playback_id = null)
    {
        $returnType = '';
        $request = $this->playRequest($channel_id, $media, $lang, $offsetms, $skipms, $playback_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'play'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback ID. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function playRequest($channel_id, $media, $lang = null, $offsetms = null, $skipms = '3000', $playback_id = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling play'
            );
        }
        // verify the required parameter 'media' is set
        if ($media === null || (is_array($media) && count($media) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media when calling play'
            );
        }

        $resourcePath = '/channels/{channelId}/play';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($media)) {
            $queryParams['media'] = $media;
        } else
        if ($media !== null) {
            $queryParams['media'] = ObjectSerializer::toQueryValue($media);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($offsetms !== null) {
            $queryParams['offsetms'] = ObjectSerializer::toQueryValue($offsetms);
        }
        // query params
        if ($skipms !== null) {
            $queryParams['skipms'] = ObjectSerializer::toQueryValue($skipms);
        }
        // query params
        if ($playback_id !== null) {
            $queryParams['playbackId'] = ObjectSerializer::toQueryValue($playback_id);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playWithId
     *
     * Start playback of media and specify the playbackId.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function playWithId($channel_id, $playback_id, $media, $lang = null, $offsetms = null, $skipms = '3000')
    {
        $this->playWithIdWithHttpInfo($channel_id, $playback_id, $media, $lang, $offsetms, $skipms);
    }

    /**
     * Operation playWithIdWithHttpInfo
     *
     * Start playback of media and specify the playbackId.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function playWithIdWithHttpInfo($channel_id, $playback_id, $media, $lang = null, $offsetms = null, $skipms = '3000')
    {
        $returnType = '';
        $request = $this->playWithIdRequest($channel_id, $playback_id, $media, $lang, $offsetms, $skipms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation playWithIdAsync
     *
     * Start playback of media and specify the playbackId.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playWithIdAsync($channel_id, $playback_id, $media, $lang = null, $offsetms = null, $skipms = '3000')
    {
        return $this->playWithIdAsyncWithHttpInfo($channel_id, $playback_id, $media, $lang, $offsetms, $skipms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playWithIdAsyncWithHttpInfo
     *
     * Start playback of media and specify the playbackId.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playWithIdAsyncWithHttpInfo($channel_id, $playback_id, $media, $lang = null, $offsetms = null, $skipms = '3000')
    {
        $returnType = '';
        $request = $this->playWithIdRequest($channel_id, $playback_id, $media, $lang, $offsetms, $skipms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playWithId'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function playWithIdRequest($channel_id, $playback_id, $media, $lang = null, $offsetms = null, $skipms = '3000')
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling playWithId'
            );
        }
        // verify the required parameter 'playback_id' is set
        if ($playback_id === null || (is_array($playback_id) && count($playback_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playback_id when calling playWithId'
            );
        }
        // verify the required parameter 'media' is set
        if ($media === null || (is_array($media) && count($media) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media when calling playWithId'
            );
        }

        $resourcePath = '/channels/{channelId}/play/{playbackId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($media)) {
            $queryParams['media'] = $media;
        } else
        if ($media !== null) {
            $queryParams['media'] = ObjectSerializer::toQueryValue($media);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($offsetms !== null) {
            $queryParams['offsetms'] = ObjectSerializer::toQueryValue($offsetms);
        }
        // query params
        if ($skipms !== null) {
            $queryParams['skipms'] = ObjectSerializer::toQueryValue($skipms);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($playback_id !== null) {
            $resourcePath = str_replace(
                '{' . 'playbackId' . '}',
                ObjectSerializer::toPathValue($playback_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation record
     *
     * Start a recording.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording (optional, default to none)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function record($channel_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        $this->recordWithHttpInfo($channel_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on);
    }

    /**
     * Operation recordWithHttpInfo
     *
     * Start a recording.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording (optional, default to none)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function recordWithHttpInfo($channel_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        $returnType = '';
        $request = $this->recordRequest($channel_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation recordAsync
     *
     * Start a recording.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording (optional, default to none)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recordAsync($channel_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        return $this->recordAsyncWithHttpInfo($channel_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recordAsyncWithHttpInfo
     *
     * Start a recording.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording (optional, default to none)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recordAsyncWithHttpInfo($channel_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        $returnType = '';
        $request = $this->recordRequest($channel_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'record'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording (optional, default to none)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function recordRequest($channel_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling record'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling record'
            );
        }
        // verify the required parameter 'format' is set
        if ($format === null || (is_array($format) && count($format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $format when calling record'
            );
        }

        $resourcePath = '/channels/{channelId}/record';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($max_duration_seconds !== null) {
            $queryParams['maxDurationSeconds'] = ObjectSerializer::toQueryValue($max_duration_seconds);
        }
        // query params
        if ($max_silence_seconds !== null) {
            $queryParams['maxSilenceSeconds'] = ObjectSerializer::toQueryValue($max_silence_seconds);
        }
        // query params
        if ($if_exists !== null) {
            $queryParams['ifExists'] = ObjectSerializer::toQueryValue($if_exists);
        }
        // query params
        if ($beep !== null) {
            $queryParams['beep'] = ObjectSerializer::toQueryValue($beep);
        }
        // query params
        if ($terminate_on !== null) {
            $queryParams['terminateOn'] = ObjectSerializer::toQueryValue($terminate_on);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redirect
     *
     * Redirect the channel to a different location.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $endpoint The endpoint to redirect the channel to (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function redirect($channel_id, $endpoint)
    {
        $this->redirectWithHttpInfo($channel_id, $endpoint);
    }

    /**
     * Operation redirectWithHttpInfo
     *
     * Redirect the channel to a different location.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $endpoint The endpoint to redirect the channel to (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function redirectWithHttpInfo($channel_id, $endpoint)
    {
        $returnType = '';
        $request = $this->redirectRequest($channel_id, $endpoint);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation redirectAsync
     *
     * Redirect the channel to a different location.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $endpoint The endpoint to redirect the channel to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectAsync($channel_id, $endpoint)
    {
        return $this->redirectAsyncWithHttpInfo($channel_id, $endpoint)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redirectAsyncWithHttpInfo
     *
     * Redirect the channel to a different location.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $endpoint The endpoint to redirect the channel to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redirectAsyncWithHttpInfo($channel_id, $endpoint)
    {
        $returnType = '';
        $request = $this->redirectRequest($channel_id, $endpoint);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redirect'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $endpoint The endpoint to redirect the channel to (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function redirectRequest($channel_id, $endpoint)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling redirect'
            );
        }
        // verify the required parameter 'endpoint' is set
        if ($endpoint === null || (is_array($endpoint) && count($endpoint) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $endpoint when calling redirect'
            );
        }

        $resourcePath = '/channels/{channelId}/redirect';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($endpoint !== null) {
            $queryParams['endpoint'] = ObjectSerializer::toQueryValue($endpoint);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ring
     *
     * Indicate ringing to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ring($channel_id)
    {
        $this->ringWithHttpInfo($channel_id);
    }

    /**
     * Operation ringWithHttpInfo
     *
     * Indicate ringing to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ringWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->ringRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ringAsync
     *
     * Indicate ringing to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ringAsync($channel_id)
    {
        return $this->ringAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ringAsyncWithHttpInfo
     *
     * Indicate ringing to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ringAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->ringRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ring'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ringRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling ring'
            );
        }

        $resourcePath = '/channels/{channelId}/ring';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation ringStop
     *
     * Stop ringing indication on a channel if locally generated.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function ringStop($channel_id)
    {
        $this->ringStopWithHttpInfo($channel_id);
    }

    /**
     * Operation ringStopWithHttpInfo
     *
     * Stop ringing indication on a channel if locally generated.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function ringStopWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->ringStopRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation ringStopAsync
     *
     * Stop ringing indication on a channel if locally generated.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ringStopAsync($channel_id)
    {
        return $this->ringStopAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation ringStopAsyncWithHttpInfo
     *
     * Stop ringing indication on a channel if locally generated.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function ringStopAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->ringStopRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'ringStop'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function ringStopRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling ringStop'
            );
        }

        $resourcePath = '/channels/{channelId}/ring';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation rtpstatistics
     *
     * RTP stats on a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function rtpstatistics($channel_id)
    {
        $this->rtpstatisticsWithHttpInfo($channel_id);
    }

    /**
     * Operation rtpstatisticsWithHttpInfo
     *
     * RTP stats on a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function rtpstatisticsWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->rtpstatisticsRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation rtpstatisticsAsync
     *
     * RTP stats on a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rtpstatisticsAsync($channel_id)
    {
        return $this->rtpstatisticsAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rtpstatisticsAsyncWithHttpInfo
     *
     * RTP stats on a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rtpstatisticsAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->rtpstatisticsRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'rtpstatistics'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function rtpstatisticsRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling rtpstatistics'
            );
        }

        $resourcePath = '/channels/{channelId}/rtp_statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendDTMF
     *
     * Send provided DTMF to a given channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $dtmf DTMF To send. (optional)
     * @param  int $before Amount of time to wait before DTMF digits (specified in milliseconds) start. (optional, default to 0)
     * @param  int $between Amount of time in between DTMF digits (specified in milliseconds). (optional, default to 100)
     * @param  int $duration Length of each DTMF digit (specified in milliseconds). (optional, default to 100)
     * @param  int $after Amount of time to wait after DTMF digits (specified in milliseconds) end. (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function sendDTMF($channel_id, $dtmf = null, $before = '0', $between = '100', $duration = '100', $after = '0')
    {
        $this->sendDTMFWithHttpInfo($channel_id, $dtmf, $before, $between, $duration, $after);
    }

    /**
     * Operation sendDTMFWithHttpInfo
     *
     * Send provided DTMF to a given channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $dtmf DTMF To send. (optional)
     * @param  int $before Amount of time to wait before DTMF digits (specified in milliseconds) start. (optional, default to 0)
     * @param  int $between Amount of time in between DTMF digits (specified in milliseconds). (optional, default to 100)
     * @param  int $duration Length of each DTMF digit (specified in milliseconds). (optional, default to 100)
     * @param  int $after Amount of time to wait after DTMF digits (specified in milliseconds) end. (optional, default to 0)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendDTMFWithHttpInfo($channel_id, $dtmf = null, $before = '0', $between = '100', $duration = '100', $after = '0')
    {
        $returnType = '';
        $request = $this->sendDTMFRequest($channel_id, $dtmf, $before, $between, $duration, $after);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation sendDTMFAsync
     *
     * Send provided DTMF to a given channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $dtmf DTMF To send. (optional)
     * @param  int $before Amount of time to wait before DTMF digits (specified in milliseconds) start. (optional, default to 0)
     * @param  int $between Amount of time in between DTMF digits (specified in milliseconds). (optional, default to 100)
     * @param  int $duration Length of each DTMF digit (specified in milliseconds). (optional, default to 100)
     * @param  int $after Amount of time to wait after DTMF digits (specified in milliseconds) end. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendDTMFAsync($channel_id, $dtmf = null, $before = '0', $between = '100', $duration = '100', $after = '0')
    {
        return $this->sendDTMFAsyncWithHttpInfo($channel_id, $dtmf, $before, $between, $duration, $after)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendDTMFAsyncWithHttpInfo
     *
     * Send provided DTMF to a given channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $dtmf DTMF To send. (optional)
     * @param  int $before Amount of time to wait before DTMF digits (specified in milliseconds) start. (optional, default to 0)
     * @param  int $between Amount of time in between DTMF digits (specified in milliseconds). (optional, default to 100)
     * @param  int $duration Length of each DTMF digit (specified in milliseconds). (optional, default to 100)
     * @param  int $after Amount of time to wait after DTMF digits (specified in milliseconds) end. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendDTMFAsyncWithHttpInfo($channel_id, $dtmf = null, $before = '0', $between = '100', $duration = '100', $after = '0')
    {
        $returnType = '';
        $request = $this->sendDTMFRequest($channel_id, $dtmf, $before, $between, $duration, $after);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendDTMF'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $dtmf DTMF To send. (optional)
     * @param  int $before Amount of time to wait before DTMF digits (specified in milliseconds) start. (optional, default to 0)
     * @param  int $between Amount of time in between DTMF digits (specified in milliseconds). (optional, default to 100)
     * @param  int $duration Length of each DTMF digit (specified in milliseconds). (optional, default to 100)
     * @param  int $after Amount of time to wait after DTMF digits (specified in milliseconds) end. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendDTMFRequest($channel_id, $dtmf = null, $before = '0', $between = '100', $duration = '100', $after = '0')
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling sendDTMF'
            );
        }

        $resourcePath = '/channels/{channelId}/dtmf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($dtmf !== null) {
            $queryParams['dtmf'] = ObjectSerializer::toQueryValue($dtmf);
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before);
        }
        // query params
        if ($between !== null) {
            $queryParams['between'] = ObjectSerializer::toQueryValue($between);
        }
        // query params
        if ($duration !== null) {
            $queryParams['duration'] = ObjectSerializer::toQueryValue($duration);
        }
        // query params
        if ($after !== null) {
            $queryParams['after'] = ObjectSerializer::toQueryValue($after);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setChannelVar
     *
     * Set the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to set (required)
     * @param  string $value The value to set the variable to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setChannelVar($channel_id, $variable, $value = null)
    {
        $this->setChannelVarWithHttpInfo($channel_id, $variable, $value);
    }

    /**
     * Operation setChannelVarWithHttpInfo
     *
     * Set the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to set (required)
     * @param  string $value The value to set the variable to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setChannelVarWithHttpInfo($channel_id, $variable, $value = null)
    {
        $returnType = '';
        $request = $this->setChannelVarRequest($channel_id, $variable, $value);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setChannelVarAsync
     *
     * Set the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to set (required)
     * @param  string $value The value to set the variable to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setChannelVarAsync($channel_id, $variable, $value = null)
    {
        return $this->setChannelVarAsyncWithHttpInfo($channel_id, $variable, $value)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setChannelVarAsyncWithHttpInfo
     *
     * Set the value of a channel variable or function.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to set (required)
     * @param  string $value The value to set the variable to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setChannelVarAsyncWithHttpInfo($channel_id, $variable, $value = null)
    {
        $returnType = '';
        $request = $this->setChannelVarRequest($channel_id, $variable, $value);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setChannelVar'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $variable The channel variable or function to set (required)
     * @param  string $value The value to set the variable to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setChannelVarRequest($channel_id, $variable, $value = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling setChannelVar'
            );
        }
        // verify the required parameter 'variable' is set
        if ($variable === null || (is_array($variable) && count($variable) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $variable when calling setChannelVar'
            );
        }

        $resourcePath = '/channels/{channelId}/variable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variable !== null) {
            $queryParams['variable'] = ObjectSerializer::toQueryValue($variable);
        }
        // query params
        if ($value !== null) {
            $queryParams['value'] = ObjectSerializer::toQueryValue($value);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation snoopChannel
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     * @param  string $snoop_id Unique ID to assign to snooping channel (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function snoopChannel($channel_id, $app, $spy = 'none', $whisper = 'none', $app_args = null, $snoop_id = null)
    {
        $this->snoopChannelWithHttpInfo($channel_id, $app, $spy, $whisper, $app_args, $snoop_id);
    }

    /**
     * Operation snoopChannelWithHttpInfo
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     * @param  string $snoop_id Unique ID to assign to snooping channel (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function snoopChannelWithHttpInfo($channel_id, $app, $spy = 'none', $whisper = 'none', $app_args = null, $snoop_id = null)
    {
        $returnType = '';
        $request = $this->snoopChannelRequest($channel_id, $app, $spy, $whisper, $app_args, $snoop_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation snoopChannelAsync
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     * @param  string $snoop_id Unique ID to assign to snooping channel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function snoopChannelAsync($channel_id, $app, $spy = 'none', $whisper = 'none', $app_args = null, $snoop_id = null)
    {
        return $this->snoopChannelAsyncWithHttpInfo($channel_id, $app, $spy, $whisper, $app_args, $snoop_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation snoopChannelAsyncWithHttpInfo
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     * @param  string $snoop_id Unique ID to assign to snooping channel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function snoopChannelAsyncWithHttpInfo($channel_id, $app, $spy = 'none', $whisper = 'none', $app_args = null, $snoop_id = null)
    {
        $returnType = '';
        $request = $this->snoopChannelRequest($channel_id, $app, $spy, $whisper, $app_args, $snoop_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'snoopChannel'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     * @param  string $snoop_id Unique ID to assign to snooping channel (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function snoopChannelRequest($channel_id, $app, $spy = 'none', $whisper = 'none', $app_args = null, $snoop_id = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling snoopChannel'
            );
        }
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling snoopChannel'
            );
        }

        $resourcePath = '/channels/{channelId}/snoop';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($spy !== null) {
            $queryParams['spy'] = ObjectSerializer::toQueryValue($spy);
        }
        // query params
        if ($whisper !== null) {
            $queryParams['whisper'] = ObjectSerializer::toQueryValue($whisper);
        }
        // query params
        if ($app !== null) {
            $queryParams['app'] = ObjectSerializer::toQueryValue($app);
        }
        // query params
        if ($app_args !== null) {
            $queryParams['appArgs'] = ObjectSerializer::toQueryValue($app_args);
        }
        // query params
        if ($snoop_id !== null) {
            $queryParams['snoopId'] = ObjectSerializer::toQueryValue($snoop_id);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation snoopChannelWithId
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $snoop_id Unique ID to assign to snooping channel (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function snoopChannelWithId($channel_id, $snoop_id, $app, $spy = 'none', $whisper = 'none', $app_args = null)
    {
        $this->snoopChannelWithIdWithHttpInfo($channel_id, $snoop_id, $app, $spy, $whisper, $app_args);
    }

    /**
     * Operation snoopChannelWithIdWithHttpInfo
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $snoop_id Unique ID to assign to snooping channel (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function snoopChannelWithIdWithHttpInfo($channel_id, $snoop_id, $app, $spy = 'none', $whisper = 'none', $app_args = null)
    {
        $returnType = '';
        $request = $this->snoopChannelWithIdRequest($channel_id, $snoop_id, $app, $spy, $whisper, $app_args);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation snoopChannelWithIdAsync
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $snoop_id Unique ID to assign to snooping channel (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function snoopChannelWithIdAsync($channel_id, $snoop_id, $app, $spy = 'none', $whisper = 'none', $app_args = null)
    {
        return $this->snoopChannelWithIdAsyncWithHttpInfo($channel_id, $snoop_id, $app, $spy, $whisper, $app_args)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation snoopChannelWithIdAsyncWithHttpInfo
     *
     * Start snooping.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $snoop_id Unique ID to assign to snooping channel (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function snoopChannelWithIdAsyncWithHttpInfo($channel_id, $snoop_id, $app, $spy = 'none', $whisper = 'none', $app_args = null)
    {
        $returnType = '';
        $request = $this->snoopChannelWithIdRequest($channel_id, $snoop_id, $app, $spy, $whisper, $app_args);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'snoopChannelWithId'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $snoop_id Unique ID to assign to snooping channel (required)
     * @param  string $app Application the snooping channel is placed into (required)
     * @param  string $spy Direction of audio to spy on (optional, default to none)
     * @param  string $whisper Direction of audio to whisper into (optional, default to none)
     * @param  string $app_args The application arguments to pass to the Stasis application (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function snoopChannelWithIdRequest($channel_id, $snoop_id, $app, $spy = 'none', $whisper = 'none', $app_args = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling snoopChannelWithId'
            );
        }
        // verify the required parameter 'snoop_id' is set
        if ($snoop_id === null || (is_array($snoop_id) && count($snoop_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snoop_id when calling snoopChannelWithId'
            );
        }
        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling snoopChannelWithId'
            );
        }

        $resourcePath = '/channels/{channelId}/snoop/{snoopId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($spy !== null) {
            $queryParams['spy'] = ObjectSerializer::toQueryValue($spy);
        }
        // query params
        if ($whisper !== null) {
            $queryParams['whisper'] = ObjectSerializer::toQueryValue($whisper);
        }
        // query params
        if ($app !== null) {
            $queryParams['app'] = ObjectSerializer::toQueryValue($app);
        }
        // query params
        if ($app_args !== null) {
            $queryParams['appArgs'] = ObjectSerializer::toQueryValue($app_args);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }
        // path params
        if ($snoop_id !== null) {
            $resourcePath = str_replace(
                '{' . 'snoopId' . '}',
                ObjectSerializer::toPathValue($snoop_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startMoh
     *
     * Play music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $moh_class Music on hold class to use (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function startMoh($channel_id, $moh_class = null)
    {
        $this->startMohWithHttpInfo($channel_id, $moh_class);
    }

    /**
     * Operation startMohWithHttpInfo
     *
     * Play music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $moh_class Music on hold class to use (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function startMohWithHttpInfo($channel_id, $moh_class = null)
    {
        $returnType = '';
        $request = $this->startMohRequest($channel_id, $moh_class);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation startMohAsync
     *
     * Play music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $moh_class Music on hold class to use (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startMohAsync($channel_id, $moh_class = null)
    {
        return $this->startMohAsyncWithHttpInfo($channel_id, $moh_class)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startMohAsyncWithHttpInfo
     *
     * Play music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $moh_class Music on hold class to use (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startMohAsyncWithHttpInfo($channel_id, $moh_class = null)
    {
        $returnType = '';
        $request = $this->startMohRequest($channel_id, $moh_class);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startMoh'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $moh_class Music on hold class to use (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startMohRequest($channel_id, $moh_class = null)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling startMoh'
            );
        }

        $resourcePath = '/channels/{channelId}/moh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($moh_class !== null) {
            $queryParams['mohClass'] = ObjectSerializer::toQueryValue($moh_class);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startSilence
     *
     * Play silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function startSilence($channel_id)
    {
        $this->startSilenceWithHttpInfo($channel_id);
    }

    /**
     * Operation startSilenceWithHttpInfo
     *
     * Play silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function startSilenceWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->startSilenceRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation startSilenceAsync
     *
     * Play silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startSilenceAsync($channel_id)
    {
        return $this->startSilenceAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startSilenceAsyncWithHttpInfo
     *
     * Play silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startSilenceAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->startSilenceRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startSilence'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startSilenceRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling startSilence'
            );
        }

        $resourcePath = '/channels/{channelId}/silence';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stopMoh
     *
     * Stop playing music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stopMoh($channel_id)
    {
        $this->stopMohWithHttpInfo($channel_id);
    }

    /**
     * Operation stopMohWithHttpInfo
     *
     * Stop playing music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stopMohWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->stopMohRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stopMohAsync
     *
     * Stop playing music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopMohAsync($channel_id)
    {
        return $this->stopMohAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stopMohAsyncWithHttpInfo
     *
     * Stop playing music on hold to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopMohAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->stopMohRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stopMoh'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stopMohRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling stopMoh'
            );
        }

        $resourcePath = '/channels/{channelId}/moh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stopSilence
     *
     * Stop playing silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stopSilence($channel_id)
    {
        $this->stopSilenceWithHttpInfo($channel_id);
    }

    /**
     * Operation stopSilenceWithHttpInfo
     *
     * Stop playing silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stopSilenceWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->stopSilenceRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stopSilenceAsync
     *
     * Stop playing silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopSilenceAsync($channel_id)
    {
        return $this->stopSilenceAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stopSilenceAsyncWithHttpInfo
     *
     * Stop playing silence to a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopSilenceAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->stopSilenceRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stopSilence'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stopSilenceRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling stopSilence'
            );
        }

        $resourcePath = '/channels/{channelId}/silence';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unhold
     *
     * Remove a channel from hold.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unhold($channel_id)
    {
        $this->unholdWithHttpInfo($channel_id);
    }

    /**
     * Operation unholdWithHttpInfo
     *
     * Remove a channel from hold.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unholdWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->unholdRequest($channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unholdAsync
     *
     * Remove a channel from hold.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unholdAsync($channel_id)
    {
        return $this->unholdAsyncWithHttpInfo($channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unholdAsyncWithHttpInfo
     *
     * Remove a channel from hold.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unholdAsyncWithHttpInfo($channel_id)
    {
        $returnType = '';
        $request = $this->unholdRequest($channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unhold'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function unholdRequest($channel_id)
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling unhold'
            );
        }

        $resourcePath = '/channels/{channelId}/hold';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unmute
     *
     * Unmute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to unmute audio (optional, default to both)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unmute($channel_id, $direction = 'both')
    {
        $this->unmuteWithHttpInfo($channel_id, $direction);
    }

    /**
     * Operation unmuteWithHttpInfo
     *
     * Unmute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to unmute audio (optional, default to both)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unmuteWithHttpInfo($channel_id, $direction = 'both')
    {
        $returnType = '';
        $request = $this->unmuteRequest($channel_id, $direction);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation unmuteAsync
     *
     * Unmute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to unmute audio (optional, default to both)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unmuteAsync($channel_id, $direction = 'both')
    {
        return $this->unmuteAsyncWithHttpInfo($channel_id, $direction)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unmuteAsyncWithHttpInfo
     *
     * Unmute a channel.
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to unmute audio (optional, default to both)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unmuteAsyncWithHttpInfo($channel_id, $direction = 'both')
    {
        $returnType = '';
        $request = $this->unmuteRequest($channel_id, $direction);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unmute'
     *
     * @param  string $channel_id Channel&#39;s id (required)
     * @param  string $direction Direction in which to unmute audio (optional, default to both)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function unmuteRequest($channel_id, $direction = 'both')
    {
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling unmute'
            );
        }

        $resourcePath = '/channels/{channelId}/mute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($direction !== null) {
            $queryParams['direction'] = ObjectSerializer::toQueryValue($direction);
        }

        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
