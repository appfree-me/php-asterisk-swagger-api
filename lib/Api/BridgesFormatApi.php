<?php
/**
 * BridgesFormatApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.43
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * BridgesFormatApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class BridgesFormatApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation addChannel
     *
     * Add a channel to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to add to bridge (required)
     * @param  string $role Channel&#39;s role in the bridge (optional)
     * @param  bool $absorb_dtmf Absorb DTMF coming from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $mute Mute audio from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $inhibit_connected_line_updates Do not present the identity of the newly connected channel to other bridge members (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function addChannel($bridge_id, $channel, $role = null, $absorb_dtmf = 'false', $mute = 'false', $inhibit_connected_line_updates = 'false')
    {
        $this->addChannelWithHttpInfo($bridge_id, $channel, $role, $absorb_dtmf, $mute, $inhibit_connected_line_updates);
    }

    /**
     * Operation addChannelWithHttpInfo
     *
     * Add a channel to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to add to bridge (required)
     * @param  string $role Channel&#39;s role in the bridge (optional)
     * @param  bool $absorb_dtmf Absorb DTMF coming from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $mute Mute audio from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $inhibit_connected_line_updates Do not present the identity of the newly connected channel to other bridge members (optional, default to false)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function addChannelWithHttpInfo($bridge_id, $channel, $role = null, $absorb_dtmf = 'false', $mute = 'false', $inhibit_connected_line_updates = 'false')
    {
        $returnType = '';
        $request = $this->addChannelRequest($bridge_id, $channel, $role, $absorb_dtmf, $mute, $inhibit_connected_line_updates);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation addChannelAsync
     *
     * Add a channel to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to add to bridge (required)
     * @param  string $role Channel&#39;s role in the bridge (optional)
     * @param  bool $absorb_dtmf Absorb DTMF coming from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $mute Mute audio from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $inhibit_connected_line_updates Do not present the identity of the newly connected channel to other bridge members (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addChannelAsync($bridge_id, $channel, $role = null, $absorb_dtmf = 'false', $mute = 'false', $inhibit_connected_line_updates = 'false')
    {
        return $this->addChannelAsyncWithHttpInfo($bridge_id, $channel, $role, $absorb_dtmf, $mute, $inhibit_connected_line_updates)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addChannelAsyncWithHttpInfo
     *
     * Add a channel to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to add to bridge (required)
     * @param  string $role Channel&#39;s role in the bridge (optional)
     * @param  bool $absorb_dtmf Absorb DTMF coming from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $mute Mute audio from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $inhibit_connected_line_updates Do not present the identity of the newly connected channel to other bridge members (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addChannelAsyncWithHttpInfo($bridge_id, $channel, $role = null, $absorb_dtmf = 'false', $mute = 'false', $inhibit_connected_line_updates = 'false')
    {
        $returnType = '';
        $request = $this->addChannelRequest($bridge_id, $channel, $role, $absorb_dtmf, $mute, $inhibit_connected_line_updates);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addChannel'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to add to bridge (required)
     * @param  string $role Channel&#39;s role in the bridge (optional)
     * @param  bool $absorb_dtmf Absorb DTMF coming from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $mute Mute audio from this channel, preventing it to pass through to the bridge (optional, default to false)
     * @param  bool $inhibit_connected_line_updates Do not present the identity of the newly connected channel to other bridge members (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function addChannelRequest($bridge_id, $channel, $role = null, $absorb_dtmf = 'false', $mute = 'false', $inhibit_connected_line_updates = 'false')
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling addChannel'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling addChannel'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/addChannel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($channel)) {
            $queryParams['channel'] = $channel;
        } else
        if ($channel !== null) {
            $queryParams['channel'] = ObjectSerializer::toQueryValue($channel);
        }
        // query params
        if ($role !== null) {
            $queryParams['role'] = ObjectSerializer::toQueryValue($role);
        }
        // query params
        if ($absorb_dtmf !== null) {
            $queryParams['absorbDTMF'] = ObjectSerializer::toQueryValue($absorb_dtmf);
        }
        // query params
        if ($mute !== null) {
            $queryParams['mute'] = ObjectSerializer::toQueryValue($mute);
        }
        // query params
        if ($inhibit_connected_line_updates !== null) {
            $queryParams['inhibitConnectedLineUpdates'] = ObjectSerializer::toQueryValue($inhibit_connected_line_updates);
        }

        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation callList
     *
     * List all active bridges in Asterisk.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function callList()
    {
        $this->callListWithHttpInfo();
    }

    /**
     * Operation callListWithHttpInfo
     *
     * List all active bridges in Asterisk.
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function callListWithHttpInfo()
    {
        $returnType = '';
        $request = $this->callListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation callListAsync
     *
     * List all active bridges in Asterisk.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callListAsync()
    {
        return $this->callListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callListAsyncWithHttpInfo
     *
     * List all active bridges in Asterisk.
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callListAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->callListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callListRequest()
    {

        $resourcePath = '/bridges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clearVideoSource
     *
     * Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clearVideoSource($bridge_id)
    {
        $this->clearVideoSourceWithHttpInfo($bridge_id);
    }

    /**
     * Operation clearVideoSourceWithHttpInfo
     *
     * Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clearVideoSourceWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->clearVideoSourceRequest($bridge_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation clearVideoSourceAsync
     *
     * Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearVideoSourceAsync($bridge_id)
    {
        return $this->clearVideoSourceAsyncWithHttpInfo($bridge_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clearVideoSourceAsyncWithHttpInfo
     *
     * Removes any explicit video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants. When no explicit video source is set, talk detection will be used to determine the active video stream.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clearVideoSourceAsyncWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->clearVideoSourceRequest($bridge_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clearVideoSource'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clearVideoSourceRequest($bridge_id)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling clearVideoSource'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/videoSource';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation create
     *
     * Create a new bridge.
     *
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single). (optional)
     * @param  string $bridge_id Unique ID to give to the bridge being created. (optional)
     * @param  string $name Name to give to the bridge being created. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function create($type = null, $bridge_id = null, $name = null)
    {
        $this->createWithHttpInfo($type, $bridge_id, $name);
    }

    /**
     * Operation createWithHttpInfo
     *
     * Create a new bridge.
     *
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single). (optional)
     * @param  string $bridge_id Unique ID to give to the bridge being created. (optional)
     * @param  string $name Name to give to the bridge being created. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithHttpInfo($type = null, $bridge_id = null, $name = null)
    {
        $returnType = '';
        $request = $this->createRequest($type, $bridge_id, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createAsync
     *
     * Create a new bridge.
     *
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single). (optional)
     * @param  string $bridge_id Unique ID to give to the bridge being created. (optional)
     * @param  string $name Name to give to the bridge being created. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsync($type = null, $bridge_id = null, $name = null)
    {
        return $this->createAsyncWithHttpInfo($type, $bridge_id, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAsyncWithHttpInfo
     *
     * Create a new bridge.
     *
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single). (optional)
     * @param  string $bridge_id Unique ID to give to the bridge being created. (optional)
     * @param  string $name Name to give to the bridge being created. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAsyncWithHttpInfo($type = null, $bridge_id = null, $name = null)
    {
        $returnType = '';
        $request = $this->createRequest($type, $bridge_id, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'create'
     *
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single). (optional)
     * @param  string $bridge_id Unique ID to give to the bridge being created. (optional)
     * @param  string $name Name to give to the bridge being created. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRequest($type = null, $bridge_id = null, $name = null)
    {

        $resourcePath = '/bridges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($bridge_id !== null) {
            $queryParams['bridgeId'] = ObjectSerializer::toQueryValue($bridge_id);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWithId
     *
     * Create a new bridge or updates an existing one.
     *
     * @param  string $bridge_id Unique ID to give to the bridge being created. (required)
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single) to set. (optional)
     * @param  string $name Set the name of the bridge. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createWithId($bridge_id, $type = null, $name = null)
    {
        $this->createWithIdWithHttpInfo($bridge_id, $type, $name);
    }

    /**
     * Operation createWithIdWithHttpInfo
     *
     * Create a new bridge or updates an existing one.
     *
     * @param  string $bridge_id Unique ID to give to the bridge being created. (required)
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single) to set. (optional)
     * @param  string $name Set the name of the bridge. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWithIdWithHttpInfo($bridge_id, $type = null, $name = null)
    {
        $returnType = '';
        $request = $this->createWithIdRequest($bridge_id, $type, $name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createWithIdAsync
     *
     * Create a new bridge or updates an existing one.
     *
     * @param  string $bridge_id Unique ID to give to the bridge being created. (required)
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single) to set. (optional)
     * @param  string $name Set the name of the bridge. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithIdAsync($bridge_id, $type = null, $name = null)
    {
        return $this->createWithIdAsyncWithHttpInfo($bridge_id, $type, $name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWithIdAsyncWithHttpInfo
     *
     * Create a new bridge or updates an existing one.
     *
     * @param  string $bridge_id Unique ID to give to the bridge being created. (required)
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single) to set. (optional)
     * @param  string $name Set the name of the bridge. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWithIdAsyncWithHttpInfo($bridge_id, $type = null, $name = null)
    {
        $returnType = '';
        $request = $this->createWithIdRequest($bridge_id, $type, $name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWithId'
     *
     * @param  string $bridge_id Unique ID to give to the bridge being created. (required)
     * @param  string $type Comma separated list of bridge type attributes (mixing, holding, dtmf_events, proxy_media, video_sfu, video_single) to set. (optional)
     * @param  string $name Set the name of the bridge. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createWithIdRequest($bridge_id, $type = null, $name = null)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling createWithId'
            );
        }

        $resourcePath = '/bridges/{bridgeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }

        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation destroy
     *
     * Shut down a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function destroy($bridge_id)
    {
        $this->destroyWithHttpInfo($bridge_id);
    }

    /**
     * Operation destroyWithHttpInfo
     *
     * Shut down a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function destroyWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->destroyRequest($bridge_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation destroyAsync
     *
     * Shut down a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destroyAsync($bridge_id)
    {
        return $this->destroyAsyncWithHttpInfo($bridge_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation destroyAsyncWithHttpInfo
     *
     * Shut down a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function destroyAsyncWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->destroyRequest($bridge_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'destroy'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function destroyRequest($bridge_id)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling destroy'
            );
        }

        $resourcePath = '/bridges/{bridgeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation get
     *
     * Get bridge details.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function get($bridge_id)
    {
        $this->getWithHttpInfo($bridge_id);
    }

    /**
     * Operation getWithHttpInfo
     *
     * Get bridge details.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->getRequest($bridge_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation getAsync
     *
     * Get bridge details.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsync($bridge_id)
    {
        return $this->getAsyncWithHttpInfo($bridge_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAsyncWithHttpInfo
     *
     * Get bridge details.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAsyncWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->getRequest($bridge_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'get'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRequest($bridge_id)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling get'
            );
        }

        $resourcePath = '/bridges/{bridgeId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation play
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback Id. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function play($bridge_id, $media, $lang = null, $offsetms = '0', $skipms = '3000', $playback_id = null)
    {
        $this->playWithHttpInfo($bridge_id, $media, $lang, $offsetms, $skipms, $playback_id);
    }

    /**
     * Operation playWithHttpInfo
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback Id. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function playWithHttpInfo($bridge_id, $media, $lang = null, $offsetms = '0', $skipms = '3000', $playback_id = null)
    {
        $returnType = '';
        $request = $this->playRequest($bridge_id, $media, $lang, $offsetms, $skipms, $playback_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation playAsync
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback Id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playAsync($bridge_id, $media, $lang = null, $offsetms = '0', $skipms = '3000', $playback_id = null)
    {
        return $this->playAsyncWithHttpInfo($bridge_id, $media, $lang, $offsetms, $skipms, $playback_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playAsyncWithHttpInfo
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback Id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playAsyncWithHttpInfo($bridge_id, $media, $lang = null, $offsetms = '0', $skipms = '3000', $playback_id = null)
    {
        $returnType = '';
        $request = $this->playRequest($bridge_id, $media, $lang, $offsetms, $skipms, $playback_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'play'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     * @param  string $playback_id Playback Id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function playRequest($bridge_id, $media, $lang = null, $offsetms = '0', $skipms = '3000', $playback_id = null)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling play'
            );
        }
        // verify the required parameter 'media' is set
        if ($media === null || (is_array($media) && count($media) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media when calling play'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/play';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($media)) {
            $queryParams['media'] = $media;
        } else
        if ($media !== null) {
            $queryParams['media'] = ObjectSerializer::toQueryValue($media);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($offsetms !== null) {
            $queryParams['offsetms'] = ObjectSerializer::toQueryValue($offsetms);
        }
        // query params
        if ($skipms !== null) {
            $queryParams['skipms'] = ObjectSerializer::toQueryValue($skipms);
        }
        // query params
        if ($playback_id !== null) {
            $queryParams['playbackId'] = ObjectSerializer::toQueryValue($playback_id);
        }

        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playWithId
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function playWithId($bridge_id, $playback_id, $media, $lang = null, $offsetms = '0', $skipms = '3000')
    {
        $this->playWithIdWithHttpInfo($bridge_id, $playback_id, $media, $lang, $offsetms, $skipms);
    }

    /**
     * Operation playWithIdWithHttpInfo
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function playWithIdWithHttpInfo($bridge_id, $playback_id, $media, $lang = null, $offsetms = '0', $skipms = '3000')
    {
        $returnType = '';
        $request = $this->playWithIdRequest($bridge_id, $playback_id, $media, $lang, $offsetms, $skipms);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation playWithIdAsync
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playWithIdAsync($bridge_id, $playback_id, $media, $lang = null, $offsetms = '0', $skipms = '3000')
    {
        return $this->playWithIdAsyncWithHttpInfo($bridge_id, $playback_id, $media, $lang, $offsetms, $skipms)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playWithIdAsyncWithHttpInfo
     *
     * Start playback of media on a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playWithIdAsyncWithHttpInfo($bridge_id, $playback_id, $media, $lang = null, $offsetms = '0', $skipms = '3000')
    {
        $returnType = '';
        $request = $this->playWithIdRequest($bridge_id, $playback_id, $media, $lang, $offsetms, $skipms);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playWithId'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $playback_id Playback ID. (required)
     * @param  string[] $media Media URIs to play. (required)
     * @param  string $lang For sounds, selects language for sound. (optional)
     * @param  int $offsetms Number of milliseconds to skip before playing. Only applies to the first URI if multiple media URIs are specified. (optional, default to 0)
     * @param  int $skipms Number of milliseconds to skip for forward/reverse operations. (optional, default to 3000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function playWithIdRequest($bridge_id, $playback_id, $media, $lang = null, $offsetms = '0', $skipms = '3000')
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling playWithId'
            );
        }
        // verify the required parameter 'playback_id' is set
        if ($playback_id === null || (is_array($playback_id) && count($playback_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $playback_id when calling playWithId'
            );
        }
        // verify the required parameter 'media' is set
        if ($media === null || (is_array($media) && count($media) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $media when calling playWithId'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/play/{playbackId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($media)) {
            $queryParams['media'] = $media;
        } else
        if ($media !== null) {
            $queryParams['media'] = ObjectSerializer::toQueryValue($media);
        }
        // query params
        if ($lang !== null) {
            $queryParams['lang'] = ObjectSerializer::toQueryValue($lang);
        }
        // query params
        if ($offsetms !== null) {
            $queryParams['offsetms'] = ObjectSerializer::toQueryValue($offsetms);
        }
        // query params
        if ($skipms !== null) {
            $queryParams['skipms'] = ObjectSerializer::toQueryValue($skipms);
        }

        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }
        // path params
        if ($playback_id !== null) {
            $resourcePath = str_replace(
                '{' . 'playbackId' . '}',
                ObjectSerializer::toPathValue($playback_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation record
     *
     * Start a recording.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit. (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit. (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording. (optional, default to none)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function record($bridge_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        $this->recordWithHttpInfo($bridge_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on);
    }

    /**
     * Operation recordWithHttpInfo
     *
     * Start a recording.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit. (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit. (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording. (optional, default to none)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function recordWithHttpInfo($bridge_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        $returnType = '';
        $request = $this->recordRequest($bridge_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation recordAsync
     *
     * Start a recording.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit. (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit. (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording. (optional, default to none)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recordAsync($bridge_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        return $this->recordAsyncWithHttpInfo($bridge_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recordAsyncWithHttpInfo
     *
     * Start a recording.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit. (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit. (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording. (optional, default to none)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recordAsyncWithHttpInfo($bridge_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        $returnType = '';
        $request = $this->recordRequest($bridge_id, $name, $format, $max_duration_seconds, $max_silence_seconds, $if_exists, $beep, $terminate_on);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'record'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $name Recording&#39;s filename (required)
     * @param  string $format Format to encode audio in (required)
     * @param  int $max_duration_seconds Maximum duration of the recording, in seconds. 0 for no limit. (optional, default to 0)
     * @param  int $max_silence_seconds Maximum duration of silence, in seconds. 0 for no limit. (optional, default to 0)
     * @param  string $if_exists Action to take if a recording with the same name already exists. (optional, default to fail)
     * @param  bool $beep Play beep when recording begins (optional, default to false)
     * @param  string $terminate_on DTMF input to terminate recording. (optional, default to none)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function recordRequest($bridge_id, $name, $format, $max_duration_seconds = '0', $max_silence_seconds = '0', $if_exists = 'fail', $beep = 'false', $terminate_on = 'none')
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling record'
            );
        }
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling record'
            );
        }
        // verify the required parameter 'format' is set
        if ($format === null || (is_array($format) && count($format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $format when calling record'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/record';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($name !== null) {
            $queryParams['name'] = ObjectSerializer::toQueryValue($name);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($max_duration_seconds !== null) {
            $queryParams['maxDurationSeconds'] = ObjectSerializer::toQueryValue($max_duration_seconds);
        }
        // query params
        if ($max_silence_seconds !== null) {
            $queryParams['maxSilenceSeconds'] = ObjectSerializer::toQueryValue($max_silence_seconds);
        }
        // query params
        if ($if_exists !== null) {
            $queryParams['ifExists'] = ObjectSerializer::toQueryValue($if_exists);
        }
        // query params
        if ($beep !== null) {
            $queryParams['beep'] = ObjectSerializer::toQueryValue($beep);
        }
        // query params
        if ($terminate_on !== null) {
            $queryParams['terminateOn'] = ObjectSerializer::toQueryValue($terminate_on);
        }

        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation removeChannel
     *
     * Remove a channel from a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to remove from bridge (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeChannel($bridge_id, $channel)
    {
        $this->removeChannelWithHttpInfo($bridge_id, $channel);
    }

    /**
     * Operation removeChannelWithHttpInfo
     *
     * Remove a channel from a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to remove from bridge (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeChannelWithHttpInfo($bridge_id, $channel)
    {
        $returnType = '';
        $request = $this->removeChannelRequest($bridge_id, $channel);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeChannelAsync
     *
     * Remove a channel from a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to remove from bridge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeChannelAsync($bridge_id, $channel)
    {
        return $this->removeChannelAsyncWithHttpInfo($bridge_id, $channel)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeChannelAsyncWithHttpInfo
     *
     * Remove a channel from a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to remove from bridge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeChannelAsyncWithHttpInfo($bridge_id, $channel)
    {
        $returnType = '';
        $request = $this->removeChannelRequest($bridge_id, $channel);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeChannel'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string[] $channel Ids of channels to remove from bridge (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeChannelRequest($bridge_id, $channel)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling removeChannel'
            );
        }
        // verify the required parameter 'channel' is set
        if ($channel === null || (is_array($channel) && count($channel) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel when calling removeChannel'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/removeChannel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($channel)) {
            $queryParams['channel'] = $channel;
        } else
        if ($channel !== null) {
            $queryParams['channel'] = ObjectSerializer::toQueryValue($channel);
        }

        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setVideoSource
     *
     * Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setVideoSource($bridge_id, $channel_id)
    {
        $this->setVideoSourceWithHttpInfo($bridge_id, $channel_id);
    }

    /**
     * Operation setVideoSourceWithHttpInfo
     *
     * Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setVideoSourceWithHttpInfo($bridge_id, $channel_id)
    {
        $returnType = '';
        $request = $this->setVideoSourceRequest($bridge_id, $channel_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation setVideoSourceAsync
     *
     * Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setVideoSourceAsync($bridge_id, $channel_id)
    {
        return $this->setVideoSourceAsyncWithHttpInfo($bridge_id, $channel_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setVideoSourceAsyncWithHttpInfo
     *
     * Set a channel as the video source in a multi-party mixing bridge. This operation has no effect on bridges with two or fewer participants.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setVideoSourceAsyncWithHttpInfo($bridge_id, $channel_id)
    {
        $returnType = '';
        $request = $this->setVideoSourceRequest($bridge_id, $channel_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setVideoSource'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $channel_id Channel&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setVideoSourceRequest($bridge_id, $channel_id)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling setVideoSource'
            );
        }
        // verify the required parameter 'channel_id' is set
        if ($channel_id === null || (is_array($channel_id) && count($channel_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $channel_id when calling setVideoSource'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/videoSource/{channelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }
        // path params
        if ($channel_id !== null) {
            $resourcePath = str_replace(
                '{' . 'channelId' . '}',
                ObjectSerializer::toPathValue($channel_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startMoh
     *
     * Play music on hold to a bridge or change the MOH class that is playing.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $moh_class Channel&#39;s id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function startMoh($bridge_id, $moh_class = null)
    {
        $this->startMohWithHttpInfo($bridge_id, $moh_class);
    }

    /**
     * Operation startMohWithHttpInfo
     *
     * Play music on hold to a bridge or change the MOH class that is playing.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $moh_class Channel&#39;s id (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function startMohWithHttpInfo($bridge_id, $moh_class = null)
    {
        $returnType = '';
        $request = $this->startMohRequest($bridge_id, $moh_class);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation startMohAsync
     *
     * Play music on hold to a bridge or change the MOH class that is playing.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $moh_class Channel&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startMohAsync($bridge_id, $moh_class = null)
    {
        return $this->startMohAsyncWithHttpInfo($bridge_id, $moh_class)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startMohAsyncWithHttpInfo
     *
     * Play music on hold to a bridge or change the MOH class that is playing.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $moh_class Channel&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startMohAsyncWithHttpInfo($bridge_id, $moh_class = null)
    {
        $returnType = '';
        $request = $this->startMohRequest($bridge_id, $moh_class);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startMoh'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     * @param  string $moh_class Channel&#39;s id (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startMohRequest($bridge_id, $moh_class = null)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling startMoh'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/moh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($moh_class !== null) {
            $queryParams['mohClass'] = ObjectSerializer::toQueryValue($moh_class);
        }

        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation stopMoh
     *
     * Stop playing music on hold to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function stopMoh($bridge_id)
    {
        $this->stopMohWithHttpInfo($bridge_id);
    }

    /**
     * Operation stopMohWithHttpInfo
     *
     * Stop playing music on hold to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function stopMohWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->stopMohRequest($bridge_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation stopMohAsync
     *
     * Stop playing music on hold to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopMohAsync($bridge_id)
    {
        return $this->stopMohAsyncWithHttpInfo($bridge_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation stopMohAsyncWithHttpInfo
     *
     * Stop playing music on hold to a bridge.
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function stopMohAsyncWithHttpInfo($bridge_id)
    {
        $returnType = '';
        $request = $this->stopMohRequest($bridge_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'stopMoh'
     *
     * @param  string $bridge_id Bridge&#39;s id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function stopMohRequest($bridge_id)
    {
        // verify the required parameter 'bridge_id' is set
        if ($bridge_id === null || (is_array($bridge_id) && count($bridge_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bridge_id when calling stopMoh'
            );
        }

        $resourcePath = '/bridges/{bridgeId}/moh';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($bridge_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bridgeId' . '}',
                ObjectSerializer::toPathValue($bridge_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
